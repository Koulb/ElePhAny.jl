var documenterSearchIndex = {"docs":
[{"location":"api/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"api/","page":"Index","title":"Index","text":"","category":"page"},{"location":"api/#Electrons","page":"Index","title":"Electrons","text":"","category":"section"},{"location":"api/#ElectronPhonon.read_qe_xml","page":"Index","title":"ElectronPhonon.read_qe_xml","text":"read_qe_xml(filename::AbstractString)\n\nReads and parses a Quantum ESPRESSO XML output file, extracting structural and electronic information.\n\nArguments\n\nfilename::AbstractString: Path to the Quantum ESPRESSO XML file.\n\nReturns\n\nA named tuple containing:\n\nlattice::Mat3: The lattice vectors in Angstroms.\natom_positions::Vector{Vec3{Float64}}: Atomic positions in fractional coordinates.\natom_labels::Vector{String}: Atomic species labels.\nrecip_lattice::Mat3: Reciprocal lattice vectors in 1/Angstrom.\nkpoints::Vector{Vec3{Float64}}: List of k-points in fractional coordinates.\nn_electrons::Float64: Number of electrons.\nfermi_energy::Float64: Fermi energy in eV.\nalat::Float64: Lattice parameter in Angstroms.\neigenvalues_up::Vector{Vector{Float64}} and eigenvalues_dn::Vector{Vector{Float64}}:   (If spin-polarized) Eigenvalues for spin-up and spin-down bands, in eV.\neigenvalues::Vector{Vector{Float64}}: (If not spin-polarized) Eigenvalues for each band, in eV.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.create_scf_calc","page":"Index","title":"ElectronPhonon.create_scf_calc","text":"create_scf_calc(path_to_scf::String, unitcell, scf_parameters)\n\nCreates a self-consistent field (SCF) calculation input for Quantum ESPRESSO.\n\nArguments\n\npath_to_scf::String: The file path where the SCF input file will be written.\nunitcell: The unit cell parameters or structure information, passed as keyword arguments to ase.Atoms.\nscf_parameters: Parameters for the SCF calculation, passed as keyword arguments to ase_io.write.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.generate_kpoints","page":"Index","title":"ElectronPhonon.generate_kpoints","text":"generate_kpoints(n1::Int, n2::Int, n3::Int; omit_weight::Bool=false, out_file::String=\"\")\n\nGenerates a Monkhorst-Pack grid of k-points for a crystal structure.\n\nArguments\n\nn1::Int: Number of k-points along the first reciprocal lattice direction. Must be > 0.\nn2::Int: Number of k-points along the second reciprocal lattice direction. Must be > 0.\nn3::Int: Number of k-points along the third reciprocal lattice direction. Must be > 0.\n\nKeyword Arguments\n\nomit_weight::Bool=false: If false, outputs k-points with weights in Quantum ESPRESSO format. If true, outputs only the k-point coordinates in a custom format.\nout_file::String=\"\": If provided, writes the output to the specified file. Otherwise, prints to standard output.\n\nOutput\n\nIf omit_weight is false, prints or writes the k-points in Quantum ESPRESSO format, including weights.\nIf omit_weight is true, prints or writes the k-points in a custom format without weights (W90 style).\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.include_kpoins","page":"Index","title":"ElectronPhonon.include_kpoins","text":"include_kpoins(path_to_nscf::String, paht_to_kpts::String)\n\nReplaces the K_POINTS section in a Quantum ESPRESSO input file with new k-points from a separate file.\n\nArguments\n\npath_to_nscf::String: Path to the NSCF input file to be modified.\npaht_to_kpts::String: Path to the file containing new k-points.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.create_disp_calc","page":"Index","title":"ElectronPhonon.create_disp_calc","text":"create_disp_calc(path_to_in::String, path_to_qe::String, unitcell, scf_parameters, abs_disp, sc_size, k_mesh, use_symm; from_scratch = false)\n\nSet up the directory structure and input files for a displacement calculation, used in electron-phonon coupling workflows.\n\nArguments\n\npath_to_in::String: Path to the working directory where calculations will be set up.\npath_to_qe::String: Path to the Quantum ESPRESSO installation or utilities.\nunitcell: The unit cell structure object.\nscf_parameters: Dictionary of parameters for the self-consistent field (SCF) calculation.\nabs_disp: Magnitude of atomic displacements to apply.\nsc_size: Supercell size (integer).\nk_mesh: Number of k-points in each direction for the k-point mesh.\nuse_symm: Boolean or flag to indicate whether to use symmetry in generating displacements.\nfrom_scratch (optional): If true, cleans and recreates the displacement directory. Default is false.\n\nDescription\n\nThis function:\n\nCreates a directory structure for displacement calculations.\nGenerates k-point files for SCF and NSCF calculations.\nPrepares input files for SCF and NSCF calculations for the undistorted and displaced structures.\nCopies necessary scripts (e.g., run.sh) into calculation directories.\nHandles special cases for hybrid functionals (e.g., nqx1, nqx2, nqx3).\nReturns the number of displaced structures generated.\n\nReturns\n\nNdispalce::Int: The number of displaced structures (and corresponding calculation groups) created.\n\n\n\n\n\ncreate_disp_calc(model::ModelKCW; from_scratch = false)\n\nCreates displacement calculations for a given ModelKCW object by preparing directories and input files for each displaced structure.\n\nArguments\n\nmodel::ModelKCW: The model containing calculation parameters and paths.\nfrom_scratch::Bool=false: (Optional) If true, forces recreation of displacement calculations from scratch.\n\nDescription\n\nThis function:\n\nChecks for the existence of required files (koopmans.json and koopmans_sc.json) in the model's calculation path.\nCreates an unperturbed directory and copies necessary files (run.sh, koopmans.json) into it.\nGenerates displaced unit cells using dislpaced_unitecells.\nFor each displacement:\nCreates a new directory (perturbedN/).\nCopies the run.sh script into the new directory.\nReads the pristine koopmans_sc.json file.\nCreates a perturbed version of the JSON data using create_perturbed_kcw.\nWrites the perturbed JSON to the corresponding directory.\n\nReturns\n\nNdispalce::Int: The number of displaced unit cells generated.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.create_disp_calc!","page":"Index","title":"ElectronPhonon.create_disp_calc!","text":"create_disp_calc!(model::ModelQE; from_scratch = false)\n\nPrepares the displacement calculation environment for a given ModelQE instance. This function manages the setup of the directory structure required for displacement calculations, optionally cleaning up any existing data if from_scratch is set to true.\n\nArguments\n\nmodel::ModelQE: The model object containing calculation parameters and paths.\nfrom_scratch::Bool=false: If true, removes the existing displacements directory before creating a new one.\n\nBehavior\n\nCleans the displacements directory if from_scratch is true.\nCreates a new displacements directory if it does not exist.\nIf model.use_symm is true, checks and applies symmetries to reduce the number of displacements.\nCalls create_disp_calc to generate the required displacement calculations.\nVerifies consistency between the number of displacements calculated by Phonopy and the symmetry calculation.\n\n\n\n\n\ncreate_disp_calc!(model::ModelKCW; from_scratch = false)\n\nPrepares the displacement calculation environment for a given model of type ModelKCW.\n\nArguments\n\nmodel::ModelKCW: The model object containing calculation parameters and paths.\nfrom_scratch::Bool=false: If true, removes the existing displacements directory before creating a new one.\n\nDescription\n\nOptionally cleans the displacements directory if from_scratch is set.\nCreates a new displacements directory in the model's calculation path.\nIf symmetry usage is enabled (model.use_symm), checks and applies symmetries.\nIf symmetries are not used, calculates the number of displacements as 6 * number of atoms and prints relevant information.\nCalls create_disp_calc(model) to generate displacements and checks for consistency in the number of displacements between Phonopy and symmetry calculations.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.create_perturbed_kcw","page":"Index","title":"ElectronPhonon.create_perturbed_kcw","text":"create_perturbed_kcw(pristine_data, unitcell)\n\nUpdates the atomic positions in the pristine_data dictionary with the scaled positions from the unitcell.\n\nReturns\n\nThe updated pristine_data dictionary with atomic positions replaced by the corresponding scaled positions from unitcell.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.run_scf","page":"Index","title":"ElectronPhonon.run_scf","text":"run_scf(path_to_in::String, mpi_ranks::Int = 0)\n\nRuns a self-consistent field (SCF) calculation using Quantum ESPRESSO's pw.x executable.\n\nArguments\n\npath_to_in::String: Path to the directory containing the scf.in input file.\nmpi_ranks::Int=0: Number of MPI ranks to use. If greater than 0, runs the calculation in parallel using mpirun; otherwise, runs in serial.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.run_scf_cluster","page":"Index","title":"ElectronPhonon.run_scf_cluster","text":"run_scf_cluster(path_to_in::String)\n\nSubmits a batch job for a self-consistent field (SCF) calculation on a computing cluster.\n\nArguments\n\npath_to_in::String: The path to the directory containing the input files and the run.sh script.\n\nDescription\n\nChanges the working directory to path_to_in, then submits the run.sh script as a batch job using sbatch. The standard output and error of the job submission command are redirected to run.out and errs.txt, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.run_nscf_calc","page":"Index","title":"ElectronPhonon.run_nscf_calc","text":"run_nscf_calc(path_to_in::String, mpi_ranks)\n\nRuns a non-self-consistent field (NSCF) calculation for electronic structure simulations.\n\nArguments\n\npath_to_in::String: The base path to the input directory containing the SCF calculation results.\nmpi_ranks: The number of MPI ranks to use for parallel execution. If greater than 0, runs the calculation in parallel.\n\nDescription\n\nThis function performs the following steps:\n\nChanges the working directory to the SCF calculation directory (scf_0).\nCopies the run.sh script to run_nscf.sh and modifies it to use nscf.in instead of scf.in.\nSubmits the NSCF calculation using sbatch if the run_nscf.sh script exists.\nIf the script does not exist, runs the calculation directly using pw.x (with or without MPI, depending on mpi_ranks).\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.run_disp_calc","page":"Index","title":"ElectronPhonon.run_disp_calc","text":"run_disp_calc(path_to_in::String, Ndispalce::Int, mpi_ranks::Int = 0) -> Bool\n\nRuns self-consistent field (SCF) calculations for a set of atomic displacements in a specified directory.\n\nArguments\n\npath_to_in::String: Path to the input directory containing displacement subdirectories.\nNdispalce::Int: Number of displacement groups to process.\nmpi_ranks::Int=0: Number of MPI ranks to use for the SCF calculation (default is 0).\n\nDescription\n\nThe function first runs an SCF calculation in the scf_0 subdirectory. If a run.sh script is present, it uses run_scf_cluster; otherwise, it uses run_scf. Then, for each displacement group (from 1 to Ndispalce), it runs the corresponding SCF calculation in the group_i subdirectory, using the same logic for run.sh.\n\n\n\n\n\nrun_disp_calc(model::ModelKCW) -> Bool\n\nRuns self-consistent field (SCF) calculations for both unperturbed and perturbed configurations of a given model.\n\nArguments\n\nmodel::ModelKCW: The model object containing calculation parameters, including the path to calculation directories and the number of displacements (Ndispalce).\n\nDescription\n\nThis function performs the following steps:\n\nRuns an SCF calculation in the \"unperturbed\" subdirectory of the specified calculation path.\nIterates over the number of displacements (Ndispalce) defined in the model, running SCF calculations in each corresponding \"perturbed\" subdirectory (e.g., \"perturbed1/\", \"perturbed2/\", etc.).\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.run_disp_nscf_calc","page":"Index","title":"ElectronPhonon.run_disp_nscf_calc","text":"run_disp_nscf_calc(path_to_in::String, Ndispalce::Int, mpi_ranks::Int = 0)\n\nRuns non-self-consistent field (NSCF) calculations for a series of atomic displacements.\n\nArguments\n\npath_to_in::String: Path to the input directory containing displacement groups.\nNdispalce::Int: Number of displacement groups to process.\nmpi_ranks::Int=0: Number of MPI ranks to use for parallel execution. If set to 0, runs in serial mode.\n\nDescription\n\nFor each displacement group (from 1 to Ndispalce), the function:\n\nChanges the working directory to the corresponding displacement group directory.\nAttempts to copy the SCF XML file containing forces to a backup file.\nCopies and modifies the run.sh script to create a run_nscf.sh script, replacing occurrences of \"scf.in\" with \"nscf.in\".\nIf a run_nscf.sh script exists, submits it as a batch job using sbatch, redirecting output and errors.\nIf not, runs the NSCF calculation directly using pw.x (with or without MPI, depending on mpi_ranks), redirecting output and errors.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.prepare_kcw_data","page":"Index","title":"ElectronPhonon.prepare_kcw_data","text":"prepare_kcw_data(model::ModelKCW) -> Int\n\nPrepares the necessary directory structure and files for Koopmans calculation for a given ModelKCW instance.\n\nArguments\n\nmodel::ModelKCW: The model object containing all relevant paths, parameters, and settings for the calculation.\n\nDescription\n\nThis function performs the following steps:\n\nCreates required directories for displacements, and electron-phonon elements.\nSets up the self-consistent field (SCF) calculation directory and copies necessary wavefunction and data files from the unperturbed calculation.\nCopies the non-self-consistent field (NSCF) output file to the SCF directory.\nGenerates a k-point mesh file for the supercell.\nCalls dislpaced_unitecells to generate displaced unit cells based on the model parameters.\nFor each displacement, creates the appropriate directory and links the corresponding wavefunction and data files from the perturbed calculations.\n\nReturns\n\nInt: The number of displacements (model.Ndispalce) processed.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.read_potential","page":"Index","title":"ElectronPhonon.read_potential","text":"read_potential(path_to_file::String; skiprows=0)\n\nReads a KS potential data file and returns a 3D array of Float64 values along with its dimensions.\n\nArguments\n\npath_to_file::String: Path to the file containing the potential data.\nskiprows: (Optional) Number of initial rows to skip in the file. Default is 0.\n\nReturns\n\nff::Array{Float64,3}: 3D array of potential values with dimensions (N1, N2, N3).\nN1::Int: Size of the first dimension.\nN2::Int: Size of the second dimension.\nN3::Int: Size of the third dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.save_potential","page":"Index","title":"ElectronPhonon.save_potential","text":"save_potential(path_to_in::String, Ndispalce, sc_size, mpi_ranks)\n\nSaves the electronic potential for a series of displaced structures by running Quantum ESPRESSO's pp.x post-processing tool.\n\nArguments\n\npath_to_in::String: Path to the directory containing input files for each displacement.\nNdispalce: Number of displacement configurations to process.\nsc_size: Size of the supercell. If greater than 1, the potential is repeated accordingly.\nmpi_ranks: Number of MPI ranks to use for parallel execution. If greater than 0, runs pp.x with MPI.\n\nDescription\n\nFor each displacement (and the undisplaced structure), this function:\n\nChanges to the appropriate directory.\nWrites a pp.in input file for pp.x with predefined parameters.\nRuns pp.x (optionally in parallel) to generate the potential file.\nFor the undisplaced structure and if sc_size > 1, reads the potential, repeats it to match the supercell size, and saves it in JLD2 format.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.get_kpoint_list","page":"Index","title":"ElectronPhonon.get_kpoint_list","text":"get_kpoint_list(path_to_in)\n\nReads a list of k-points from a file named kpoints.dat located in the directory specified by path_to_in.\n\nArguments\n\npath_to_in::AbstractString: Path to the directory containing the kpoints.dat file.\n\nReturns\n\nklist::Vector{Vector{Float64}}: A vector of k-points, where each k-point is represented as a vector of Float64 values.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.fold_kpoint","page":"Index","title":"ElectronPhonon.fold_kpoint","text":"fold_kpoint(ik, iq, k_list)\n\nGiven indices ik and iq into the list of k-points k_list, the function computes the index of the k-point in k_list that corresponds to the sum of k_list[ik] and k_list[iq], folded back into the first Brillouin zone.\n\nArguments\n\nik::Int: Index of the first k-point in k_list.\niq::Int: Index of the second k-point in k_list.\nk_list::AbstractVector{<:AbstractVector}: List of k-points (each k-point is a vector).\n\nReturns\n\nikq::Int: Index in k_list of the folded sum of k_list[ik] and k_list[iq].\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.prepare_eigenvalues","page":"Index","title":"ElectronPhonon.prepare_eigenvalues","text":"prepare_eigenvalues(path_to_in::String, natoms::Int; Ndisplace::Int = 6*natoms, ineq_atoms_list::Vector{Int}=[], spin_channel::String=\"\")\n\nPrepares and saves eigenvalues for displaced atomic configurations.\n\nArguments\n\npath_to_in::String: Path to the input directory containing calculation data.\nnatoms::Int: Number of atoms in the system.\nNdisplace::Int=6*natoms: Number of atomic displacements (default is 6 times the number of atoms).\nineq_atoms_list::Vector{Int}=[]: List of indices for inequivalent atoms (used if Ndisplace differs from 6*natoms).\nspin_channel::String=\"\": Spin channel to use; can be \"up\", \"dw\", or \"\" for non-spin-polarized.\n\nReturns\n\nA tuple containing:\n\nϵkᵤ_list: Eigenvalues for the undistorted structure.\nϵₚ_list: List of eigenvalues for positive displacements.\nϵₚₘ_list: List of eigenvalues for negative displacements.\nk_list: List of k-points.\n\nSaves\n\nscf_0/ek_list.jld2: Eigenvalues for the undistorted structure.\nscf_0/ep_list.jld2: Eigenvalues for positive displacements.\nscf_0/epm_list.jld2: Eigenvalues for negative displacements.\nscf_0/k_list.jld2: List of k-points.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.create_electrons","page":"Index","title":"ElectronPhonon.create_electrons","text":"create_electrons(path_to_in::String, natoms::Int, sc_size::Int, k_mesh::Int) -> Electrons\n\nCreates and returns an Electrons object by preparing the necessary matrices and eigenvalues.\n\nArguments\n\npath_to_in::String: Path to the input file or directory containing required data.\nnatoms::Int: Number of atoms in the system.\nsc_size::Int: Supercell size.\nk_mesh::Int: Number of k-points in the mesh.\n\nReturns\n\nElectrons: An Electrons object initialized with the computed matrices and eigenvalues.\n\n\n\n\n\ncreate_electrons(model::AbstractModel)\n\nCreates an Electrons object based on the provided model. This function extracts relevant properties from the model, such as spin_channel and symmetries, and uses them to prepare the necessary matrices and eigenvalues for the electron calculations.\n\nArguments\n\nmodel::AbstractModel: The model containing all necessary information about the system, including unit cell, calculation paths, supercell size, k-point mesh, and optional properties like spin_channel and symmetries.\n\nReturns\n\nElectrons: An object containing the prepared U and V matrices, eigenvalues, and k-point list for the electron system.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.load_electrons","page":"Index","title":"ElectronPhonon.load_electrons","text":"load_electrons(model::AbstractModel) -> Electrons\n\nLoads electron-related data from disk for the given model. The function reads several arrays from JLD2 files located in the displacements/scf_0/ subdirectory of model.path_to_calc, including:\n\nU_list: Unitary matrices for electron states.\nV_list: Additional matrices for electron states.\nϵkᵤ_list: Eigenvalues of undisplaced configuration.\nϵₚ_list: Eigenvalues of displaced (+tau) configuration.\nϵₚₘ_list: Eigenvalues of displaced (-tau) configuration.\nk_list: List of k-points in reciprocal space.\n\nReturns an Electrons object constructed from the loaded data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Phonons","page":"Index","title":"Phonons","text":"","category":"section"},{"location":"api/#ElectronPhonon.determine_q_point","page":"Index","title":"ElectronPhonon.determine_q_point","text":"determine_q_point(path_to_in, iq; sc_size=1, use_sc=false)\n\nDetermines the q-point from a k-points file.\n\nArguments\n\npath_to_in::AbstractString: Path to the directory containing the k-points files.\niq::Integer: Index of the q-point to retrieve (1-based).\nsc_size::Number=1: Scaling factor for the q-point (default is 1).\nuse_sc::Bool=false: If true, use the supercell k-points file (kpoints_sc.dat); otherwise, use the regular k-points file (kpoints.dat).\n\nReturns\n\nVector{Float64}: The q-point at index iq, scaled by sc_size.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.determine_q_point_cart","page":"Index","title":"ElectronPhonon.determine_q_point_cart","text":"determine_q_point_cart(path_to_in, ik)\n\nExtracts the Cartesian coordinates of the ik-th k-point from a Quantum ESPRESSO scf.out file located in the specified directory.\n\nArguments\n\npath_to_in::String: Path to the directory containing the scf.out file.\nik::Int: Index of the k-point to extract (1-based).\n\nReturns\n\nVector{Float64}: A vector of length 3 containing the Cartesian coordinates of the specified k-point.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.read_forces_xml","page":"Index","title":"ElectronPhonon.read_forces_xml","text":"read_forces_xml(path_to_xml::String) -> Matrix{Float64}\n\nReads atomic forces from a Quantum ESPRESSO XML output file.\n\nArguments\n\npath_to_xml::String: Path to the XML file containing the forces data.\n\nReturns\n\nMatrix{Float64}: A matrix of size (N_atoms, 3), where each row corresponds to the force vector (in Hartree/Bohr) acting on an atom.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.dislpaced_unitecells","page":"Index","title":"ElectronPhonon.dislpaced_unitecells","text":"dislpaced_unitecells(path_to_save, unitcell, abs_disp, sc_size, use_symm)\n\nGenerates supercells with atomic displacements for phonon calculations using Phonopy.\n\nArguments\n\npath_to_save::String: Path where the Phonopy parameter file (phonopy_params.yaml) will be saved.\nunitcell::Dict: Dictionary describing the unit cell. Must contain keys :symbols, :cell, :scaled_positions, and :masses.\nabs_disp::Float64: Magnitude of the atomic displacement (in Angstroms).\nsc_size::Int: Size of the supercell (applied equally along all three axes).\nuse_symm::Bool: Whether to use symmetry operations in generating displacements.\n\nReturns\n\nsupercells::Vector{Dict}: A vector of dictionaries, each representing a supercell with displaced atoms. Each dictionary contains keys :symbols, :cell, :scaled_positions, and :masses.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.collect_forces","page":"Index","title":"ElectronPhonon.collect_forces","text":"collect_forces(path_to_in::String, unitcell, sc_size, Ndispalce)\n\nCollects atomic forces from a series of displacement calculations.\n\nArguments\n\npath_to_in::String: Path to the directory containing displacement calculation results.\nunitcell: Data structure containing information about the unit cell, including atomic symbols.\nsc_size: Integer specifying the size of the supercell (number of unit cells along one dimension).\nNdispalce: Number of displacement calculations (i.e., number of displaced configurations).\n\nReturns\n\nforces::Array{Float64, 3}: 3D array of shape (Ndispalce, number_atoms, 3) containing the forces for each displacement and atom.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.save_dyn_matirx","page":"Index","title":"ElectronPhonon.save_dyn_matirx","text":"save_dyn_matirx(path_to_in::String, sc_size::Int) -> Bool\n\nSaves the dynamical matrices for a supercell of size sc_size^3 to disk.\n\nArguments\n\npath_to_in::String: Path to the input directory containing phonopy files (e.g., phonopy_params.yaml).\nsc_size::Int: The size of the supercell along one dimension (total number of q-points is sc_size^3).\n\nDescription\n\nFor each q-point in the supercell:\n\nLoads phonon parameters using Phonopy.\nComputes the dynamical matrix at the q-point.\nApplies phase and mass factors to construct the dynamical matrix in QE gage.\nSaves the resulting matrix to a file in a newly created dyn_mat subdirectory.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.prepare_phonons_data","page":"Index","title":"ElectronPhonon.prepare_phonons_data","text":"prepare_phonons_data(path_to_in::String, unitcell, abs_disp, sc_size, k_mesh, use_symm, Ndispalce::Int64; save_dynq=true)\n\nPrepares phonon data by collecting forces and processing them for further calculations.\n\nArguments\n\npath_to_in::String: Path to the input directory or file containing force data.\nunitcell: The unit cell structure or object.\nabs_disp: Absolute displacement value(s) used for phonon calculations.\nsc_size: Supercell size or dimensions.\nk_mesh: k-point mesh for Brillouin zone sampling.\nuse_symm: Boolean or flag indicating whether to use symmetry operations.\nNdispalce::Int64: Number of displacements to consider.\nsave_dynq (optional): Whether to save the dynamical matrix (true by default).\n\nReturns\n\nThe processed phonon data, ready for further analysis or calculations.\n\n\n\n\n\nprepare_phonons_data(path_to_in::String, unitcell, abs_disp, sc_size, k_mesh, use_symm, forces::Array{Float64}; save_dynq=true)\n\nPrepares phonon calculation data using Phonopy and Quantum ESPRESSO.\n\nArguments\n\npath_to_in::String: Path to the input directory where files will be read/written.\nunitcell: Dictionary containing unit cell information, including :symbols, :cell, and :scaled_positions.\nabs_disp: Absolute displacement value for generating phonon displacements.\nsc_size: Integer specifying the size of the supercell.\nk_mesh: Integer specifying the k-point mesh size.\nuse_symm: Boolean indicating whether to use symmetry in phonon calculations.\nforces::Array{Float64}: Array of forces to be set in the phonon object.\nsave_dynq (optional, default=true): Whether to save the dynamical matrix after calculation.\n\nDescription\n\nThis function:\n\nConverts unit cell parameters to the appropriate units and format for Phonopy.\nInitializes a Phonopy object with the given unit cell, supercell size, and symmetry settings.\nProduces and optionally symmetrizes the force constants.\nSaves Phonopy parameters to a YAML file.\nConstructs and writes a configuration file for further phonon calculations.\nRuns the Phonopy command-line tool to compute phonon properties.\nOptionally saves the dynamical matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.prepare_phonons","page":"Index","title":"ElectronPhonon.prepare_phonons","text":"prepare_phonons(path_to_in::String, sc_size::Int)\n\nPrepares and processes phonon data for a given system.\n\nArguments\n\npath_to_in::String: Path to the input directory containing phonopy and phonon calculation files.\nsc_size::Int: Size of the supercell (used to determine the number of q-points).\n\nOutputs\n\nM_phonon: Array of transformation matrices for each atom, used to convert between Cartesian and phonon displacement bases.\nωₐᵣᵣ_ₗᵢₛₜ: List of phonon frequency arrays for each q-point.\nεₐᵣᵣ_ₗᵢₛₜ: List of phonon eigenvector arrays for each q-point.\nmₐᵣᵣ: Array of atomic masses.\n\nSide Effects\n\nSaves the following files in the scf_0 subdirectory of path_to_in:\n\nM_phonon.jld2: Contains the transformation matrices.\nm_arr.jld2: Contains the atomic masses.\nomega_arr_list.jld2: Contains the list of phonon frequencies.\neps_arr_list.jld2: Contains the list of phonon eigenvectors.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.create_phonons","page":"Index","title":"ElectronPhonon.create_phonons","text":"create_phonons(path_to_in::String, sc_size::Int) -> Phonons\n\nCreates a Phonons object by preparing phonon data.\n\nArguments\n\npath_to_in::String: Path to the input file containing phonon data.\nsc_size::Int: Supercell size parameter used for phonon preparation.\n\nReturns\n\nPhonons: An instance of the Phonons type containing the mass matrix, frequency array, eigenvector array, and mass array.\n\n\n\n\n\ncreate_phonons(model::AbstractModel) -> Phonons\n\nCreates a Phonons object for the given model. This function prepares the phonon data by calculating the supercell size, loading phonon matrices, frequencies, eigenvectors, and atomic masses from the specified displacement calculation directory.\n\nArguments\n\nmodel::AbstractModel: The model containing information about the k-point mesh, supercell size, and path to displacement calculations.\n\nReturns\n\nPhonons: An object containing the phonon matrix, frequency arrays, eigenvector arrays, and atomic mass array.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.load_phonons","page":"Index","title":"ElectronPhonon.load_phonons","text":"load_phonons(model::AbstractModel) -> Phonons\n\nLoads phonon-related data from disk for the given model and returns a Phonons object.\n\nArguments\n\nmodel::AbstractModel: The model containing the path to the calculation directory.\n\nReturns\n\nPhonons: An object containing the loaded phonon mass matrix (M_phonon),\n\nlist of phonon frequencies (ωₐᵣᵣ_ₗᵢₛₜ), list of phonon eigenvectors (εₐᵣᵣ_ₗᵢₛₜ), and atomic masses (mₐᵣᵣ).\n\n\n\n\n\n","category":"function"},{"location":"api/#Electron-phonon-coupling","page":"Index","title":"Electron-phonon coupling","text":"","category":"section"},{"location":"api/#ElectronPhonon.run_calculations","page":"Index","title":"ElectronPhonon.run_calculations","text":"run_calculations(model::ModelQE)\n\nPerforms a series of calculations for a given ModelQE instance related to electron and phonon interactions.\n\nArguments\n\nmodel::ModelQE: The model containing calculation parameters and paths.\n\nDescription\n\nThis function runs the following calculations in sequence:\n\nElectron displacement calculations using run_disp_calc.\nNon-self-consistent field (NSCF) calculations using run_nscf_calc.\nDisplacement NSCF calculations using run_disp_nscf_calc.\n\nAll calculations are performed in the directory specified by model.path_to_calc * \"displacements/\", using the number of displacements (model.Ndispalce) and MPI ranks (model.mpi_ranks) specified in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.prepare_model","page":"Index","title":"ElectronPhonon.prepare_model","text":"prepare_model(model::ModelQE)\n\nPrepares the model for electron-phonon calculations based on the provided ModelQE object.\n\nArguments\n\nmodel::ModelQE: The model configuration containing calculation parameters, paths, and settings.\n\nDescription\n\nThis function performs the following steps:\n\nChecks for unsupported combinations of symmetry and k-point mesh in supercell calculations.\nFor calculations with both k-point mesh and supercell size greater than 1, reads structural data, computes a unified grid, and prepares undistorted and distorted wave functions.\nFor calculations with only supercell size greater than 1 (and k-point mesh equal to 1), prepares undistorted wave functions.\nPrepares phonon data for all cases.\n\n\n\n\n\nprepare_model(model::ModelKCW)\n\nPrepares the given ModelKCW model for further calculations. This function performs the following steps:\n\nCalls prepare_kcw_data(model) to set up necessary data for the model.\nCalls prepare_wave_functions_undisp with the path to the displacement calculations and the supercell size to prepare wave functions without displacements.\n\nArguments\n\nmodel::ModelKCW: The model object containing all necessary parameters and paths for preparation.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.electron_phonon_qe","page":"Index","title":"ElectronPhonon.electron_phonon_qe","text":"electron_phonon_qe(path_to_in::String, ik::Int, iq::Int, mpi_ranks::Int, path_to_qe::String)\n\nRuns a Quantum ESPRESSO phonon calculation for electron-phonon coupling at specified k- and q-points.\n\nArguments\n\npath_to_in::String: Path to the input directory containing calculation files.\nik::Int: Index of the k-point to use.\niq::Int: Index of the q-point to use.\nmpi_ranks::Int: Number of MPI ranks (processes) to use for parallel execution.\npath_to_qe::String: Path to the Quantum ESPRESSO installation or executable directory.\n\nDescription\n\nThis function:\n\nChanges the working directory to the specified input directory.\nConstructs a dictionary of input parameters for the ph.x Quantum ESPRESSO module.\nWrites the input file ph.in for the phonon calculation.\nExecutes the ph.x program using MPI, redirecting output and error streams to files.\n\n\n\n\n\nelectron_phonon_qe(model::ModelQE, ik::Int, iq::Int)\n\nComputes electron-phonon coupling using  Quantum ESPRESSO for a given model.\n\nArguments\n\nmodel::ModelQE: The Quantum ESPRESSO model containing calculation parameters and paths.\nik::Int: Index of the k-point.\niq::Int: Index of the q-point.\n\nReturns\n\nThe result of the electron-phonon coupling calculation for the specified k-point and q-point.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.find_degenerate","page":"Index","title":"ElectronPhonon.find_degenerate","text":"find_degenerate(energies, thr=1e-3)\n\nGroups nearly degenerate energy levels within a given threshold.\n\nArguments\n\nenergies::AbstractVector{<:Real}: A vector of energy values, assumed to be sorted.\nthr::Real=1e-3: Threshold for considering two energies as degenerate (default: 1e-3).\n\nReturns\n\nineq_ener::Vector{<:Real}: Vector of unique (inequivalent) energies, each representing a group of degenerate states.\neq_states::Vector{Vector{Int}}: A vector of vectors, where each subvector contains the indices of energies that are degenerate with the corresponding entry in ineq_ener.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.parse_ph","page":"Index","title":"ElectronPhonon.parse_ph","text":"parse_ph(file_name, nbands, nfreq)\n\nParse electron-phonon matrix elements from a ph.out file.\n\nArguments\n\nfile_name::AbstractString: Path to the input file containing electron-phonon data.\nnbands::Int: Number of electronic bands.\nnfreq::Int: Number of phonon frequencies.\n\nReturns\n\nelph_dfpt::Array{ComplexF64,3}: A 3D array of size (nbands, nbands, nfreq) containing the parsed electron-phonon matrix elements (in meV).\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.electron_phonon","page":"Index","title":"ElectronPhonon.electron_phonon","text":"electron_phonon(\n    path_to_in::String,\n    abs_disp,\n    Nat,\n    ik,\n    iq,\n    sc_size,\n    k_mesh,\n    ϵkᵤ_list,\n    ϵₚ_list,\n    ϵₚₘ_list,\n    k_list,\n    U_list,\n    V_list,\n    M_phonon,\n    ωₐᵣᵣ_ₗᵢₛₜ,\n    εₐᵣᵣ_ₗᵢₛₜ,\n    mₐᵣᵣ;\n    save_epw::Bool=false\n)\n\nCompute electron-phonon matrix elements using the frozen-phonon approach.\n\nArguments\n\npath_to_in::String: Path to the input calculation directory.\nabs_disp: Absolute displacement used in frozen-phonon calculations.\nNat: Number of atoms in the unit cell.\nik: Index of the k-point.\niq: Index of the q-point.\nsc_size: Supercell size.\nk_mesh: Number of k-points in the mesh.\nϵkᵤ_list: List of eigenvalues for each k-point.\nϵₚ_list: List of perturbed eigenvalues for positive displacement.\nϵₚₘ_list: List of perturbed eigenvalues for negative displacements.\nk_list: List of k-points.\nU_list: List of braket matrices for positive displacements.\nV_list: List of braket matrices for negative displacements.\nM_phonon: List of phonon rotation matrices for each atom.\nωₐᵣᵣ_ₗᵢₛₜ: List of phonon frequencies for each q-point.\nεₐᵣᵣ_ₗᵢₛₜ: List of phonon eigenvectors for each q-point.\nmₐᵣᵣ: List of atomic masses.\nsave_epw::Bool=false: If true, saves the rotated braket list for EPW.\n\nReturns\n\nIf save_epw is true, returns the rotated braket list (braket_list_rotated).\nOtherwise, returns the symmetrized electron-phonon matrix elements (symm_elph).\n\nDescription\n\nThis function computes the electron-phonon coupling matrix elements by evaluating the overlap (\"braket\") between electronic states perturbed by atomic displacements. The calculation is performed for each atom and Cartesian direction, and the results are rotated into the phonon eigenmode basis. The function also symmetrizes the resulting matrix elements over phonon and electronic states and compares them with DFPT results if available.\n\n\n\n\n\nelectron_phonon(path_to_in::String, abs_disp, natoms, ik, iq, sc_size, electrons::AbstractElectrons, phonons::AbstractPhonons; save_epw::Bool=false, path_to_calc=\"\", kcw_chanel=\"\")\n\nHigh-level interface for computing electron-phonon interactions when Electrons and Phonons are provided.\n\nArguments\n\npath_to_in::String: Path to the input file or directory.\nabs_disp: Absolute displacement parameter (type depends on context).\nnatoms: Number of atoms in the system.\nik: Index of the k-point.\niq: Index of the q-point.\nsc_size: Supercell size.\nelectrons::AbstractElectrons: Object containing electronic structure data.\nphonons::AbstractPhonons: Object containing phonon data.\n\nKeyword Arguments\n\nsave_epw::Bool=false: Whether to save the EPW (Electron-Phonon Wannier) data.\npath_to_calc=\"\": Optional path to calculation directory.\nkcw_chanel=\"\": Optional kcw channel specification.\n\n\n\n\n\nelectron_phonon(model::AbstractModel, ik, iq, electrons::AbstractElectrons, phonons::AbstractPhonons; save_epw::Bool=false, path_to_calc=\"\", kcw_chanel=\"\")\n\nCompute electron-phonon coupling properties for the given model, electron, and phonon objects.\n\nArguments\n\nmodel::AbstractModel: The model containing system parameters and calculation paths.\nik: Index or identifier for the electron k-point.\niq: Index or identifier for the phonon q-point.\nelectrons::AbstractElectrons: Object containing electronic structure data (eigenvalues, k-points, etc.).\nphonons::AbstractPhonons: Object containing phonon properties (modes, frequencies, etc.).\n\nKeyword Arguments\n\nsave_epw::Bool=false: Whether to save the electron-phonon Wannier (EPW) data.\npath_to_calc::String=\"\": Path to the calculation directory (overrides model's path if provided).\nkcw_chanel::String=\"\": Optional spin chanel for KCW (\"up\" has KI functional and \"down\" has DFT).\n\nDescription\n\nThis function prepares and calls the lower-level electron-phonon coupling calculation using the provided model, electron, and phonon data. It extracts relevant properties from the electrons and phonons objects and passes them, along with model and calculation parameters, to the core computation routine.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.plot_ep_coupling","page":"Index","title":"ElectronPhonon.plot_ep_coupling","text":"plot_ep_coupling(path_to_in::String, ik::Int, iq::Int; nbnd_max=-1)\n\nReads electron-phonon coupling data from a specified file, generates a scatter plot comparing two coupling values, and saves the plot as a PNG image.\n\nArguments\n\npath_to_in::String: Path to the input directory containing the out/comparison_ik_iq.txt file.\nik::Int: Index of the k-point used in the filename.\niq::Int: Index of the q-point used in the filename.\nnbnd_max::Int (optional; default: -1): If greater than 0, only data with band indices less than nbnd_max are included.\n\nReturns\n\n(x, y): Two arrays of Float64 containing DFPT and FP data.\n\n\n\n\n\nplot_ep_coupling(model::ModelQE, ik::Int=0, iq::Int=0; nbnd_max=-1)\n\nPlots the electron-phonon coupling for a given ModelQE instance.\n\nArguments\n\nmodel::ModelQE: The model containing electron-phonon calculation data.\nik::Int=0: Index of the k-point to plot (default is 0).\niq::Int=0: Index of the q-point to plot (default is 0).\n\nKeyword Arguments\n\nnbnd_max::Int=-1: Maximum number of bands to include in the plot (default is -1, which may indicate all bands).\n\n\n\n\n\n","category":"function"},{"location":"api/#Symmetries","page":"Index","title":"Symmetries","text":"","category":"section"},{"location":"api/#ElectronPhonon.check_symmetries","page":"Index","title":"ElectronPhonon.check_symmetries","text":"check_symmetries(path_to_calc, unitcell, sc_size, abs_disp)\n\nChecks the symmetries of atomic displacements in a crystal structure using Phonopy.\n\nArguments\n\npath_to_calc::String: Path to the calculation directory where displacement files will be saved.\nunitcell::Dict: Dictionary containing unit cell information with keys:\n:symbols: Atomic symbols.\n:cell: Lattice vectors.\n:scaled_positions: Atomic positions in scaled coordinates.\n:masses: Atomic masses.\nsc_size::Int: Size of the supercell (applied equally along all axes).\nabs_disp::Float64: Magnitude of the atomic displacement to generate.\n\nReturns\n\nSymmetries: An object containing:\nList of inequivalent atom indices.\nList of translation vectors for each symmetry operation.\nList of rotation matrices for each symmetry operation.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.check_symmetries!","page":"Index","title":"ElectronPhonon.check_symmetries!","text":"check_symmetries!(model::AbstractModel)\n\nChecks the symmetries of the given model and updates its symmetry-related fields in-place.\n\nArguments\n\nmodel::AbstractModel: The model object containing calculation path, unit cell, supercell size, and displacement information.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.fold_component","page":"Index","title":"ElectronPhonon.fold_component","text":"fold_component(x, eps=5e-3)\n\nFolds the input value x into the interval [0, 1) within a tolerance eps.\n\nIf x is greater than or equal to 1 - eps, repeatedly subtracts 1 until x falls within the interval. If x is less than 0 - eps, repeatedly adds 1 until x falls within the interval.\n\nArguments\n\nx: The value to be folded.\neps: (optional) Tolerance for the interval boundaries. Default is 1e-3.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.rotate_grid","page":"Index","title":"ElectronPhonon.rotate_grid","text":"rotate_grid(N1, N2, N3, rot, tras)\n\nMaps a 3D grid of points onto itself under a given rotation and translation, returning a mapping of indices.\n\nArguments\n\nN1::Int: Number of grid points along the first axis.\nN2::Int: Number of grid points along the second axis.\nN3::Int: Number of grid points along the third axis.\nrot::AbstractMatrix: 3x3 rotation matrix to apply to each grid point.\ntras::AbstractVector: 3-element translation vector to apply after rotation (in fractional coordinates).\n\nReturns\n\nmapp::Vector{Int}: A vector containing the mapped linear indices for each grid point after applying the rotation and translation.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.rotate_deriv","page":"Index","title":"ElectronPhonon.rotate_deriv","text":"rotate_deriv(N1, N2, N3, mapp, ff)\n\nRotate a 3D array ff according to a mapping array mapp and the specified dimensions N1, N2, N3.\n\nArguments\n\nN1::Int: Size of the first dimension.\nN2::Int: Size of the second dimension.\nN3::Int: Size of the third dimension.\nmapp::Vector{Int}: Mapping array that specifies the new indices for rotation. Each entry maps a linear index in the original array to a new position.\nff::Array{ComplexF64,3}: The original 3D array to be rotated.\n\nReturns\n\nff_rot::Array{ComplexF64,3}: The rotated 3D array.\n\n\n\n\n\n","category":"function"},{"location":"api/#Wave-functions","page":"Index","title":"Wave functions","text":"","category":"section"},{"location":"api/#ElectronPhonon.parse_wf","page":"Index","title":"ElectronPhonon.parse_wf","text":"parse_wf(path::String)\n\nParses a wave function file specified by path. The function checks for the existence of either a .dat or .hdf5 file with the given base path. Returns a tuple (miller, evc_list) containing the Miller indices and the eigenvector coefficients.\n\nArguments\n\npath::String: The base path (without extension) to the wave function file.\n\nReturns\n\nmiller: Miller indices 3xNG.\nevc_list: List of eigenvector coefficients parsed from the file NbandsxNg.\n\nThrows\n\nAn error if neither a .dat nor a .hdf5 file is found at the specified path.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.parse_hdf","page":"Index","title":"ElectronPhonon.parse_hdf","text":"parse_hdf(path::String) -> (miller, evc_list)\n\nParse an HDF5 file at the given path to extract Miller indices and eigenvector coefficients.\n\nArguments\n\npath::String: The file path to the HDF5 file.\n\nReturns\n\nmiller: Array containing Miller indices.\nevc_list: Vector of complex eigenvector coefficients, where each element corresponds to a band.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.parse_fortran_bin","page":"Index","title":"ElectronPhonon.parse_fortran_bin","text":"parse_fortran_bin(path::String) -> (miller, evc_list)\n\nParse an Fortran biniary file at the given path to extract Miller indices and eigenvector coefficients.\n\nArguments\n\npath::String: The file path to the wfc#.dat file.\n\nReturns\n\nmiller: Array containing Miller indices.\nevc_list: Vector of complex eigenvector coefficients, where each element corresponds to a band.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.wf_from_G","page":"Index","title":"ElectronPhonon.wf_from_G","text":"wf_from_G(miller::Matrix{Int32}, evc::Vector{ComplexF64}, Nxyz) -> Array{ComplexF64, 3}\n\nConstructs a real-space wave function from its plane-wave expansion coefficients in reciprocal space.\n\nArguments\n\nmiller::Matrix{Int32}: A 3×N matrix where each column represents a Miller index (reciprocal lattice vector) for a plane wave component.\nevc::Vector{ComplexF64}: A vector of complex coefficients corresponding to each Miller index, representing the amplitude and phase of each plane wave.\nNxyz: The size of the cubic grid in each spatial dimension (assumes a cubic box of size Nxyz × Nxyz × Nxyz).\n\nReturns\n\nwave_function::Array{ComplexF64, 3}: The reconstructed wave function in real space, represented as a 3D array of complex values.\n\nDetails\n\nThe function maps Miller indices to the appropriate indices in a reciprocal space grid, fills in the provided coefficients, and then performs an inverse FFT (using bfft after ifftshift) to obtain the real-space wave function.\nThe Miller indices are shifted and wrapped to fit within the grid dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.wf_from_G_slow","page":"Index","title":"ElectronPhonon.wf_from_G_slow","text":"wf_from_G_slow(miller::Matrix{Int32}, evc::Vector{ComplexF64}, Nxyz) -> Array{ComplexF64,3}\n\nConstructs a real-space wave function on a 3D grid from its plane-wave expansion coefficients withot FFT.\n\nArguments\n\nmiller::Matrix{Int32}: A matrix where each column represents a reciprocal lattice vector (Miller indices) for the plane-wave basis.\nevc::Vector{ComplexF64}: The expansion coefficients (eigenvector components) corresponding to each plane-wave basis vector.\nNxyz: The number of grid points along each spatial dimension (assumes a cubic grid).\n\nReturns\n\nwave_function::Array{ComplexF64,3}: The computed wave function values on a 3D grid of size (Nxyz, Nxyz, Nxyz).\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.wf_from_G_list","page":"Index","title":"ElectronPhonon.wf_from_G_list","text":"wf_from_G_list(miller::Matrix{Int32}, evc_list::AbstractArray{Any}, Nxyz) -> Array{ComplexF64, 4}\n\nConstructs the real-space wave function from a list of plane-wave coefficients and their corresponding Miller indices.\n\nArguments\n\nmiller::Matrix{Int32}: A 3×N matrix where each column contains the Miller indices (G-vectors) for a plane wave.\nevc_list::AbstractArray{Any}: A list (or array) of Nbands wave-functions' coefficients corresponding to each G-vector.\nNxyz: The size of the cubic grid in each spatial direction.\n\nReturns\n\nwave_function::Array{ComplexF64, 4}: A 4D array of complex values representing the wave function in real space, with dimensions (N_evc, Nxyz, Nxyz, Nxyz), where N_evc is the number of eigenvector coefficients.\n\nDescription\n\nThis function maps the plane-wave coefficients onto a reciprocal space grid according to their Miller indices, applies an inverse FFT shift, and then performs an inverse FFT to obtain the real-space wave function. The function is parallelized over the Miller index list for efficiency.\n\nNotes\n\nThe Miller indices are shifted to map correctly onto the FFT grid.\nThe function assumes a cubic grid and that the Miller indices are provided in the correct format.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.wf_to_G","page":"Index","title":"ElectronPhonon.wf_to_G","text":"wf_to_G(miller::Matrix{Int32}, wfc, Nxyz) -> Vector{ComplexF64}\n\nTransforms a wave function wfc from real space to G-space using the provided Miller indices.\n\nArguments\n\nmiller::Matrix{Int32}: A 3×N matrix where each column represents a Miller index (G-vector) in reciprocal space.\nwfc: The wave function Nxyz×Nxyz×Nxyz in real space, assumed to be a 3D array compatible with FFT operations.\nNxyz: The size of the FFT grid along each dimension (assumed cubic).\n\nReturns\n\nevc_sc::Vector{ComplexF64}: The wave function coefficients in G-space, normalized.\n\nNotes\n\nThe function applies an FFT and fftshift to the input wave function, then extracts the coefficients corresponding to the provided Miller indices.\nThe output is normalized such that its norm is 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.wf_to_G_list","page":"Index","title":"ElectronPhonon.wf_to_G_list","text":"wf_to_G_list(miller::Matrix{Int32}, wfc::AbstractArray{ComplexF64, 4}, Nxyz) -> Matrix{ComplexF64}\n\nTransforms a list of real-space wave functions wfc into a list of G-space wave functions.\n\nArguments\n\nmiller::Matrix{Int32}: A 3×Ng matrix where each column represents the Miller indices (G-vector components) for which the plane-wave coefficients are to be extracted.\nwfc::AbstractArray{ComplexF64, 4}: The real-space wave function array with dimensions (Nbands, Nx, Ny, Nz), where Nevc is the number of eigenvectors (bands), and Nx, Ny, Nz are the grid sizes in each spatial direction.\nNxyz: The size of the FFT grid in each spatial direction (assumed cubic).\n\nReturns\n\nevc_sc::Matrix{ComplexF64}: A matrix of size (Nbands, NG), where each column contains the plane-wave coefficients for the corresponding G-vector from miller.\n\nNotes\n\nThe function assumes that the FFT grid is cubic (Nx = Ny = Nz = Nxyz).\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.wf_pc_to_sc","page":"Index","title":"ElectronPhonon.wf_pc_to_sc","text":"wf_pc_to_sc(wfc, sc_size)\n\nExpands a wave function wfc defined in a primitive cell to a supercell of size sc_size × sc_size × sc_size.\n\nArguments\n\nwfc: The wave function array defined in the primitive cell.\nsc_size: The size of the supercell along each spatial dimension.\n\nReturns\n\nwfc_sc: The wave function array repeated to fill the supercell.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.determine_fft_grid","page":"Index","title":"ElectronPhonon.determine_fft_grid","text":"determine_fft_grid(path_to_file::String; use_xml::Bool = false) -> Int\n\nDetermines the FFT grid size (Nxyz) from a given file.\n\nArguments\n\npath_to_file::String: Path to the file containing FFT grid information. This can be either an XML file or a plain text output file.\nuse_xml::Bool = false: If true, parses the file as an XML file; otherwise, parses it as a plain text file.\n\nReturns\n\nNxyz: The FFT grid size along each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.determine_phase","page":"Index","title":"ElectronPhonon.determine_phase","text":"determine_phase(q_point, Nxyz)\n\nCompute the phase factor exp(2im * π * dot(r, q_point)) on a 3D grid of size Nxyz × Nxyz × Nxyz.\n\nArguments\n\nq_point::AbstractVector: A 3-element vector representing the q-point in reciprocal space.\nNxyz: The number of grid points along each spatial dimension.\n\nReturns\n\nexp_factor::Array{Complex{Float64},3}: A 3D array of complex phase factors evaluated at each grid point.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.prepare_unfold_to_sc","page":"Index","title":"ElectronPhonon.prepare_unfold_to_sc","text":"prepare_unfold_to_sc(path_to_in::String, sc_size::Int, ik::Int)\n\nPrepares and saves the unfolded wave functions for a supercell calculation.\n\nArguments\n\npath_to_in::String: Path to the input directory containing required files.\nsc_size::Int: Supercell size multiplier.\nik::Int: Index of the k-point to process.\n\nDescription\n\nThis function performs the following steps:\n\nDetermines the q-point vector for the specified k-point.\nCalculates the phase factor for the q-point and FFT grid.\nLoads the list of wave functions from a JLD2 file.\nFor each wave function:\nConverts it from primitive cell to supercell representation.\nApplies the calculated phase factor.\nStores the processed wave function in a new dictionary.\nSaves the processed wave functions to a new JLD2 file with a modified filename.\n\nOutput\n\nSaves the processed wave functions with phase factors applied to a file named wfc_list_phase_ik.jld2 in the specified input directory.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.wf_phase!","page":"Index","title":"ElectronPhonon.wf_phase!","text":"wf_phase!(path_to_in::String, wfc::AbstractArray{ComplexF64, 4}, sc_size::Int, ik::Int)\n\nApplies a phase factor to an array of complex wave functions  wfc in-place, based on the specified supercell size and k-point index.\n\nArguments\n\npath_to_in::String: Path to the input directory containing SCF calculation outputs.\nwfc::AbstractArray{ComplexF64, 4}: 4D array Nbands × Nxyz × Nxyz × Nxyz representing the wave functions to be modified.\nsc_size::Int: Supercell size multiplier.\nik::Int: Index of the k-point for which the phase factor is determined.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.prepare_wave_functions_to_R","page":"Index","title":"ElectronPhonon.prepare_wave_functions_to_R","text":"prepare_wave_functions_to_R(path_to_in::String; ik::Int=1)\n\nPrepares and saves wave functions in real space for a given k-point index.\n\nArguments\n\npath_to_in::String: Path to the input directory containing calculation results.\nik::Int=1: (Optional) Index of the k-point to process. Defaults to 1.\n\nOutput\n\nSaves a dictionary of wave functions to a file named wfc_list_<ik>.jld2 in the specified input directory.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.prepare_wave_functions_to_G","page":"Index","title":"ElectronPhonon.prepare_wave_functions_to_G","text":"prepare_wave_functions_to_G(path_to_in::String; ik::Int=1)\n\nLoads wave function in real space from a specified directory, transforms them to G-space and saves the resulting data.\n\nArguments\n\npath_to_in::String: Path to the input directory containing the wave function files.\nik::Int=1: (Optional) Index of the k-point to process.\n\nDescription\n\nThis function:\n\nLoads the wave function list for the specified k-point from a JLD2 file.\nDetermines the grid size and Miller indices by parsing a reference wave function file.\nTransforms each wave function in the list to G-space using wf_to_G.\nSaves the resulting dictionary of G-space wave functions to a new JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.prepare_wave_functions_undisp","page":"Index","title":"ElectronPhonon.prepare_wave_functions_undisp","text":"prepare_wave_functions_undisp(path_to_in::String, ik::Int, sc_size::Int)\n\nPrepares wave functions for further calculations by performing the following steps:\n\nTransforms wave functions to real (R) space for the specified k-point.\nUnfolds the wave functions to the supercell of given size.\nTransforms the wave functions back to reciprocal (G) space.\n\nArguments\n\npath_to_in::String: Path to the input directory containing wave function data.\nik::Int: Index of the k-point to process.\nsc_size::Int: Size of the supercell for unfolding.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.prepare_wave_functions_disp","page":"Index","title":"ElectronPhonon.prepare_wave_functions_disp","text":"prepare_wave_functions_disp(path_to_in::String, ik::Int, Ndisplace::Int, sc_size::Int, k_mesh::Int)\n\nPrepares and processes wave functions for a set of displaced structures in a supercell calculation.\n\nArguments\n\npath_to_in::String: Path to the input directory containing data for each displacement group.\nik::Int: Index of the k-point for which the wave functions are prepared.\nNdisplace::Int: Number of displacement groups to process.\nsc_size::Int: Size of the supercell (number of unit cells along one dimension).\nk_mesh::Int: Number of k-points in the mesh (currently unused in the function).\n\nDescription\n\nFor each displacement group, this function:\n\nParses the wave function coefficients from the corresponding data files.\nProcesses the wave functions in chunks to manage memory usage:\nConverts G-space coefficients to real-space wave functions.\nApplies phase factor.\nConverts the corrected wave functions back to G-space.\nSaves the phase-corrected wave function coefficients to a JLD2 file for each displacement group.\n\n\n\n\n\nprepare_wave_functions_disp(path_to_in::String, Ndisplace::Int, sc_size::Int, k_mesh::Int)\n\nA wrapper function that calls another method of prepare_wave_functions_disp with an additional k-point index argument.\n\nArguments\n\npath_to_in::String: Path to the input directory or file.\nNdisplace::Int: Number of displacements to consider.\nsc_size::Int: Size of the supercell.\nk_mesh::Int: Number of k-points along each reciprocal lattice direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.calculate_braket_real","page":"Index","title":"ElectronPhonon.calculate_braket_real","text":"calculate_braket_real(bra::Array{Complex{Float64}, 3}, ket::Array{Complex{Float64}, 3}) -> Complex{Float64}\n\nCalculates the normalized inner product ⟨bra|ket⟩ between two 3D complex-valued arrays bra and ket.\n\nArguments\n\nbra::Array{Complex{Float64}, 3}: The \"bra\" vector, represented as a 3D array of complex numbers.\nket::Array{Complex{Float64}, 3}: The \"ket\" vector, represented as a 3D array of complex numbers.\n\nReturns\n\nComplex{Float64}: The normalized inner product ⟨bra|ket⟩, computed as the sum over all elements of conj(bra[i]) * ket[i], divided by the total number of elements.\n\n\n\n\n\ncalculate_braket_real(bras::Dict{String, Array{Complex{Float64}, 3}}, kets::Dict{String, Array{Complex{Float64}, 3}}) -> Array{Complex{Float64}, 2}\n\nCompute the matrix of real-valued inner product ⟨bra|ket⟩ values between sets of \"bra\" and \"ket\" wave functions.\n\nArguments\n\nbras: A dictionary mapping string identifiers to 3-dimensional arrays of complex numbers, representing the \"bra\" wave functions.\nkets: A dictionary mapping string identifiers to 3-dimensional arrays of complex numbers, representing the \"ket\" wave functions.\n\nReturns\n\nA 2D array of complex numbers where the element at position (i, j) contains the result of calculate_braket_real applied to the i-th bra and j-th ket.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.calculate_braket","page":"Index","title":"ElectronPhonon.calculate_braket","text":"calculate_braket(bra::Array{Complex{Float64}}, ket::Array{Complex{Float64}}) -> Complex{Float64}\n\nComputes the inner product ⟨bra|ket⟩ between two complex-valued vectors.\n\nArguments\n\nbra::Array{Complex{Float64}}: The \"bra\" vector (conjugate transpose).\nket::Array{Complex{Float64}}: The \"ket\" vector.\n\nReturns\n\nComplex{Float64}: The resulting inner product as a complex number.\n\n\n\n\n\ncalculate_braket(bras, kets)\n\nCompute the matrix of inner products ⟨bra|ket⟩ between two collections of quantum states.\n\nArguments\n\nbras: A collection (e.g., array or vector) of bra vectors (quantum states).\nkets: A collection (e.g., array or vector) of ket vectors (quantum states).\n\nReturns\n\nA matrix of complex numbers where the element at position (i, j) is the inner product between bras[i] and kets[j].\n\n\n\n\n\n","category":"function"},{"location":"api/#Model","page":"Index","title":"Model","text":"","category":"section"},{"location":"api/#ElectronPhonon.Symmetries","page":"Index","title":"ElectronPhonon.Symmetries","text":"Symmetries\n\nA structure representing the symmetries of a system.\n\nFields\n\nineq_atoms_list::Vector{Int64}: List of indices of inequivalent atoms in the system.\ntrans_list::Vector{Vector{Float64}}: List of translation vectors associated with each symmetry operation.\nrot_list::Vector{Matrix{Float64}}: List of rotation matrices corresponding to each symmetry operation.\n\n\n\n\n\n","category":"type"},{"location":"api/#ElectronPhonon.ModelQE","page":"Index","title":"ElectronPhonon.ModelQE","text":"ModelQE <: AbstractModel\n\nA mutable struct representing a Quantum ESPRESSO (QE) model configuration.\n\nFields\n\npath_to_calc::String: Path to the calculation directory.\nabs_disp::Float64: Absolute displacement value used in calculations.\npath_to_qe::String: Path to the Quantum ESPRESSO executable.\nmpi_ranks::Int: Number of MPI ranks to use for parallel execution.\nsc_size::Int: Supercell size.\nk_mesh::Int: Number of k-points in the mesh.\nNdispalce::Int: Number of displacements.\nunitcell::Dict: Dictionary containing unit cell information.\nscf_parameters::Dict: Dictionary of self-consistent field (SCF) parameters.\nuse_symm::Bool: Whether to use symmetry in calculations.\nsymmetries::Symmetries: Symmetry information associated with the model.\n\n\n\n\n\n","category":"type"},{"location":"api/#ElectronPhonon.ModelKCW","page":"Index","title":"ElectronPhonon.ModelKCW","text":"ModelKCW <: AbstractModel\n\nA mutable struct representing a Koopmans model configuration.\n\nFields\n\npath_to_calc::String: Path to the calculation directory.\nspin_channel::String: Spin channel used in the calculation (e.g., \"up\", \"down\").\nabs_disp::Float64: Absolute displacement value for phonon calculations.\npath_to_qe::String: Path to the Quantum ESPRESSO executable.\nmpi_ranks::Int: Number of MPI ranks to use for parallel calculations.\nsc_size::Int: Supercell size.\nk_mesh::Int: Number of k-points in the mesh.\nNdispalce::Int: Number of displacements.\nunitcell::Dict: Dictionary containing unit cell information.\nscf_parameters::Dict: Dictionary of self-consistent field (SCF) parameters.\nuse_symm::Bool: Whether to use symmetry in calculations.\nsymmetries::Symmetries: Symmetry operations associated with the model.\n\n\n\n\n\n","category":"type"},{"location":"api/#ElectronPhonon.create_model","page":"Index","title":"ElectronPhonon.create_model","text":"create_model(; path_to_calc::String = \"./\",\n               abs_disp::Float64 = 1e-3,\n               path_to_qe::String = \"./\",\n               mpi_ranks::Int = 1,\n               sc_size::Int = 2,\n               k_mesh::Int = 1,\n               Ndispalce::Int = 0,\n               unitcell::Dict = Dict(),\n               scf_parameters::Dict = Dict(),\n               use_symm::Bool = false,\n               symmetries::Symmetries = Symmetries([],[],[]))\n\nCreate and initialize a ModelQE object with the specified parameters.\n\nKeyword Arguments\n\npath_to_calc::String = \"./\": Path to the calculation directory.\nabs_disp::Float64 = 1e-3: Absolute displacement value for atomic positions.\npath_to_qe::String = \"./\": Path to the Quantum ESPRESSO executable.\nmpi_ranks::Int = 1: Number of MPI ranks to use for calculations.\nsc_size::Int = 2: Size of the supercell.\nk_mesh::Int = 1: Number of k-points in the mesh.\nNdispalce::Int = 0: Number of displacements to consider.\nunitcell::Dict = Dict(): Dictionary containing unit cell information.\nscf_parameters::Dict = Dict(): Dictionary of self-consistent field (SCF) parameters.\nuse_symm::Bool = false: Whether to use symmetries in the calculation.\nsymmetries::Symmetries = Symmetries([],[],[]): Symmetry operations to use.\n\nReturns\n\nModelQE: An initialized ModelQE object with the specified settings.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.create_model_kcw","page":"Index","title":"ElectronPhonon.create_model_kcw","text":"create_model_kcw(path_to_calc::String,\n                 spin_channel::String,\n                 abs_disp::Float64,\n                 path_to_qe::String,\n                 mpi_ranks::Int,\n                 sc_size::Int,\n                 k_mesh::Int,\n                 Ndispalce::Int,\n                 unitcell::Dict,\n                 scf_parameters::Dict,\n                 use_symm::Bool)\n\nCreate and return a ModelKCW object with the specified parameters.\n\nArguments\n\npath_to_calc::String: Path to the calculation directory.\nspin_channel::String: Spin channel identifier (e.g., \"up\", \"down\").\nabs_disp::Float64: Absolute displacement value.\npath_to_qe::String: Path to the Quantum ESPRESSO executable.\nmpi_ranks::Int: Number of MPI ranks to use.\nsc_size::Int: Supercell size.\nk_mesh::Int: Number of k-points in the mesh.\nNdispalce::Int: Number of displacements.\nunitcell::Dict: Dictionary containing unit cell information.\nscf_parameters::Dict: Dictionary of self-consistent field (SCF) parameters.\nuse_symm::Bool: Whether to use symmetry in calculations.\n\nReturns\n\nModelKCW: An instance of the ModelKCW type initialized with the provided parameters.\n\n\n\n\n\ncreate_model_kcw(; path_to_calc::String = \"./\",\n                  spin_channel::String = \"up\",\n                  abs_disp::Float64 = 1e-3,\n                  path_to_qe::String = \"./\",\n                  mpi_ranks::Int = 1,\n                  sc_size::Int = 2,\n                  k_mesh::Int = 1,\n                  Ndispalce::Int = 0,\n                  unitcell::Dict = Dict(),\n                  scf_parameters::Dict = Dict(),\n                  use_symm::Bool = false,\n                  symmetries::Symmetries = Symmetries([],[],[]))\n\nCreate and initialize a ModelKCW object with the specified parameters.\n\nKeyword Arguments\n\npath_to_calc::String: Path to the calculation directory. Defaults to \"./\".\nspin_channel::String: Spin channel to use (e.g., \"up\" or \"down\"). Defaults to \"up\".\nabs_disp::Float64: Absolute displacement value. Defaults to 1e-3.\npath_to_qe::String: Path to Quantum ESPRESSO executables. Defaults to \"./\".\nmpi_ranks::Int: Number of MPI ranks to use. Defaults to 1.\nsc_size::Int: Supercell size. Defaults to 2.\nk_mesh::Int: Number of k-points in the mesh. Defaults to 1.\nNdispalce::Int: Number of displacements. Defaults to 0.\nunitcell::Dict: Dictionary describing the unit cell. Defaults to an empty Dict().\nscf_parameters::Dict: Dictionary of self-consistent field (SCF) parameters. Defaults to an empty Dict().\nuse_symm::Bool: Whether to use symmetries. Defaults to false.\nsymmetries::Symmetries: Symmetries object. Defaults to Symmetries([],[],[],[]).\n\nReturns\n\nModelKCW: An initialized ModelKCW object.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.Electrons","page":"Index","title":"ElectronPhonon.Electrons","text":"Electrons\n\nA structure representing electronic properties in a model.\n\nFields\n\nU_list::Array: List of brakets beetwen displaced(+tau) and undisplaced wavefunctions.\nV_list::Array: List of brakets beetwen displaced(-tau) and undisplaced wavefunctions.\nϵkᵤ_list::Array: List of undisplaced electronic energies.\nϵₚ_list::Array: List of displaced(+tau) electronic energies.\nϵₚₘ_list::Array: List of displaced(+tau) electronic energies.\nk_list::Array: List of k-points.\n\n\n\n\n\n","category":"type"},{"location":"api/#ElectronPhonon.Phonons","page":"Index","title":"ElectronPhonon.Phonons","text":"Phonons\n\nA structure representing phonon properties.\n\nFields\n\nM_phonon::Array{}: Array transfromation from crystall to cartesian basis.\nωₐᵣᵣ_ₗᵢₛₜ::Array{}: Array of phonon frequencies.\nεₐᵣᵣ_ₗᵢₛₜ::Array{}: Array of phonon energies or eigenvalues.\nmₐᵣᵣ::Array{}: Array of masses (typically Float64).\n\nNotes\n\nAll fields are currently typed as Array{}. For improved type safety and performance, consider specifying element types, e.g., Array{Float64}.\n\n\n\n\n\n","category":"type"},{"location":"api/#IO","page":"Index","title":"IO","text":"","category":"section"},{"location":"api/#ElectronPhonon.parse_frozen_params","page":"Index","title":"ElectronPhonon.parse_frozen_params","text":"parse_frozen_params(path_to_json)\n\nParses a JSON file containing parameters for a frozen phonon calculation and merges them with default values.\n\nArguments\n\npath_to_json::AbstractString: Path to the JSON file containing parameter overrides.\n\nReturns\n\nDict{String, Any}: A dictionary with the merged parameters, where defaults are used unless overridden by the JSON file.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.parse_qe_in","page":"Index","title":"ElectronPhonon.parse_qe_in","text":"parse_qe_in(path_to_scf::String)\n\nParses a Quantum ESPRESSO SCF input file and extracts structural and calculation parameters.\n\nArguments\n\npath_to_scf::String: Path to the Quantum ESPRESSO SCF input file.\n\nReturns\n\nunitcell::Dict: A dictionary containing unit cell information:\n:symbols: Chemical symbols of the atoms.\n:cell: Lattice vectors of the unit cell.\n:scaled_positions: Atomic positions in fractional coordinates.\n:masses: Atomic masses.\nscf_parameters::Dict: A dictionary containing parsed SCF calculation parameters, including:\n:format: The format of the input file (set to \"espresso-in\").\n:crystal_coordinates: Boolean indicating if crystal coordinates are used.\nAdditional parameters parsed from the input file.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.getfirst","page":"Index","title":"ElectronPhonon.getfirst","text":"getfirst(f::Function, A)\n\nReturns the first element el in the collection A for which the predicate function f(el) returns true. If no such element is found, returns nothing.\n\nArguments\n\nf::Function: A predicate function that takes an element of A and returns a Bool.\nA: A collection to search through.\n\n\n\n\n\n","category":"function"},{"location":"api/#ElectronPhonon.parse_file","page":"Index","title":"ElectronPhonon.parse_file","text":"parse_file(f::AbstractString, parse_funcs::Vector{<:Pair{NeedleType, Any}}; out = Dict{Symbol, Any}())\n\nParses the file at path f line by line, applying parsing functions specified in parse_funcs to lines that match given patterns.\n\nArguments\n\nf::AbstractString: Path to the file to be parsed.\nparse_funcs::Vector{<:Pair{NeedleType, Any}}: A vector of pairs, where each pair consists of a pattern (NeedleType) to search for in each line, and a parsing function to apply when the pattern is found. The parsing function should accept three arguments: the output dictionary, the current line, and the file handle.\nout::Dict{Symbol, Any} (optional): An output dictionary to store parsed results. Defaults to an empty dictionary.\n\nReturns\n\nDict{Symbol, Any}: The dictionary containing parsed results.\n\n\n\n\n\nparse_file(f::AbstractString, args...; kwargs...)\n\nOpens the file specified by the path f in read mode and passes the resulting file handle, along with any additional positional (args...) and keyword arguments (kwargs...), to the inner parse_file method for further processing.\n\nArguments\n\nf::AbstractString: The path to the file to be parsed.\nargs...: Additional positional arguments to be forwarded to the inner parse_file method.\nkwargs...: Additional keyword arguments to be forwarded to the inner parse_file method.\n\n\n\n\n\n","category":"function"},{"location":"theory/#theory","page":"Theory","title":"Electron-Phonon Coupling – Theory Recap","text":"","category":"section"},{"location":"theory/#Effective-Potential-Expansion-and-E–ph-Hamiltonian","page":"Theory","title":"Effective Potential Expansion and E–ph Hamiltonian","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"When atoms vibrate from their equilibrium positions, the electronic effective potential changes. This gives rise to an electron–phonon interaction Hamiltonian that can be written as: ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"hatH^mathrmetext-ph = sum_kappaalphal fracpartial hatVpartial tau_kappaalpha ldelta tau_kappaalpha l","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where hatV is the effective potential, and tau_kappaalpha l denotes the alpha-component of the position of atom kappa in the unit cell at lattice vector mathbfR_l. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/#Electron-Phonon-Matrix-Element-Definition","page":"Theory","title":"Electron-Phonon Matrix Element Definition","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The electron–phonon (e–ph) matrix element g_mnnu(mathbfkmathbfq) represents the probability amplitude for an electron in an initial Bloch state  psi_nmathbfkrangle to scatter into a final state  psi_mmathbfk+qrangle by interacting with a phonon of branch nu and wavevector mathbfq:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"g_mnnu(mathbfkmathbfq) = sum_kappaalpha sqrtfrachbar2 M_kappa omega_mathbfqnu e_kappaalphamathbfqnu Biglangle psi_mmathbfk+qBig fracpartial Vpartial tau_kappaalpha Bigpsi_nmathbfkBigrangle","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"with M_kappa the atomic mass, omega_mathbfqnu the phonon frequency, and e_kappaalphamathbfqnu the phonon eigenvector.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/#Motivation:-Challenges-with-Finite-Differences","page":"Theory","title":"Motivation: Challenges with Finite Differences","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since the DFPT method currently doesn't allow us to get any functionals of interest (e.g, Hybrids), we could use a general finite difference approach. Even though a simple finite difference formula could obtain the derivative of the potential partial V, there are cases where it is challenging to do so: ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Nonlocal part of the potential in pseudopotential form require special treatment.  \nBeyond-DFT methods (hybrids, Koopmans, GW) include orbital-dependent nonlocal operators, which forces to save different potentials for different orbitals.  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/#Eigenvalue-Based-Projectability-Approach","page":"Theory","title":"Eigenvalue-Based Projectability Approach","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Instead of explicitly evaluating partial V, we rewrite the derivative in the form of the derivative of the Hamiltonian:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"fracpartial hatHpartial tau_kappaalpha approx frachatH(+Deltatau) - hatH(-Deltatau)2Deltatau","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Inserting the identity sum_j psi_j^pmrangle langlepsi_j^pm with wave functions of the displaced systems gives:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Biglangle psi_mmathbfk+qBig fracpartial Vpartial tau_kappaalphaBig psi_nmathbfkBigrangle approx \nfrac12Deltatau\nsum_j^N^rm max\nBig(varepsilon_j^+ u^+*_mmathbfk+qju^+_jnmathbfk\n-varepsilon_j^- u^-*_mmathbfk+qju^-_jnmathbfkBig)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where u^pm_jnmathbfk=langle psi_j^pm  psi_nmathbfkrangle are overlap coefficients.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Advantages:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Works for any pseudopotential or functional (DFT and beyond).  \nRequires only eigenvalues and eigenvectors of pristine and displaced systems.  \nAutomatically yields g_mnnu for mathbfk and mathbfq points commensurate with the supercell.  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/#Approximations","page":"Theory","title":"Approximations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Finite difference step: requires convergence with respect to Deltatau.  \nTruncated basis: the completeness of the identity is approximated with N^rm max states; small size of the perturbation ensures accuracy.  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"theory/#Symmetry-Reduction","page":"Theory","title":"Symmetry Reduction","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The number of displacements can be reduced from 3N^rm at to N^rm in by using space-group symmetries.  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Only inequivalent atoms and directions need to be displaced.  \nWavefunctions for equivalent displacements are generated by symmetry transformations.  ","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example demonstrates the calculation of electron-phonon matrix elements for Silicon on a mathbfk=mathbfq=2times2times2 grid using the projectability approach with PBE and HSE functionals.  ","category":"page"},{"location":"examples/#Silicon-with-PBE","page":"Examples","title":"Silicon with PBE","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first step is loading the ElePhAny module together with PythonCall, as we are using the ASE and Phonopy libraries to handle the creation of Quantum Espresso inputs and phonon calculations, respectively.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":" using ElectronPhonon, PythonCall","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then, we need to decide where to create the folder with the corresponding data for the finite difference (FD) calculation. Consider that we set path_to_calc to the same path where the si.jl script for the calculation is located. We expect the following structure of the calculation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"path_to_calc = pwd() * \"/\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":".\n├── si.jl\n├── run.sh\n└── displacements\n    ├── dyn_mat\n    ├── epw\n    ├── group_1\n    ...\n    ├── group_12\n    ├── out\n    ├── phonopy_params.yaml\n    ├── phonopy.yaml\n    ├── qpoints.yaml\n    ├── scf_0\n    └── sc_size.conf","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's break it down piece by piece. Inside displacement folder, there are group_* folders that contain input/output of the displaced configurations (scf.in scf.out nscf.in nscf.out) that we need for further post-processing.  scf_0 folders contain information about pristine calculation together with *jld2 files that are needed for restarting of the code once the post-processing is partially finished. phonopy_params.yaml and phonopy.yaml qpoints.yaml sc_size.conf contains information related to Phonopy calculation.  out folder contains information about electron-phonon elements calculated with DFPT and FD on the coarse-grid for a given ik and iq point per file. epw and dyn_mat folders are needed for further interface with EPW package.  If run.sh is also present in the root folder, then subsequent executions of QE are going to be done using Slurm, and run.sh is going to be copied in all the group_* and scf_0 folders. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we need to set up additional settings for the FD calculation: abs_disp is the size of the finite displacement which we are going to apply to atoms (Bohr). path_to_qe is an optional path to the Quantum Espresso (QE) source folder, needed only when we want to compare results of FD with DFPT; otherwise, ElePhAny assumes that QE executables are on the path. To access electron-phonon elements, you will need to compile a special version of the ph.x code located in testsuite/non_epw_comp of QE. The following parameter, mpi_ranks, is required for the parallel execution of QE. It is ignored if run.sh is present and calculations are run using Slurm. The use_symm flag corresponds to whether symmetries of displaced configurations are going to be used or every atom of the unit cell is going to be perturbed. At last, sc_size corresponds to the supercell size, which corresponds to the mathbfq grid. k_mesh corresponds to the k-points sampling of the supercells. To have consistency between pristine unit cells and displaced supercells, k-point sampling of the pristine unit cell is a product of sc_size times k_mesh.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"#Params\nabs_disp = 1e-3\npath_to_qe= \"/home/poliukhin/Soft/sourse/q-e/\"\nmpi_ranks = 8\nuse_symm = false\nsc_size = [2,2,2]\nk_mesh  = [1,1,1]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The final step in setting up the calculation is to create the QE input file for the pristine system. It is handled by ASE and Phonopy packages, for which we need to provide unitcell and scf_parameters python-like dictionaries. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Lattice constant of Silicon\na = 5.43052   in Angstrom\n\nunitcell = Dict(\n    :symbols =>  pylist([\"Si\", \"Si\"]),\n    :cell => pylist([[-0.5 * a, 0.0, 0.5 * a],\n    [0.0, 0.5 * a, 0.5 * a],\n    [-0.5 * a, 0.5 * a, 0.0]]),\n    :scaled_positions => pylist([(0, 0, 0), (0.75, 0.75, 0.75)]),\n    :masses => pylist([28.08550, 28.08550])\n)\n\n# Set up the calculation parameters as a Python dictionary\nscf_parameters = Dict(\n    :format => \"espresso-in\",\n    :kpts => pytuple((k_mesh[1]*sc_size[1], k_mesh[2]*sc_size[2], k_mesh[3]*sc_size[3])),\n    :calculation =>\"scf\",\n    :prefix => \"scf\",\n    :outdir => \"./tmp/\",\n    :pseudo_dir => \"/home/poliukhin/Development/frozen_phonons/elph/example/pseudo\",\n    :ecutwfc => 60,\n    :conv_thr =>1.e-13,\n    :pseudopotentials => Dict(\"Si\" => \"Si.upf\"),\n    :diagonalization => \"ppcg\",#david\n    :mixing_mode => \"plain\",\n    :mixing_beta => 0.7,\n    :crystal_coordinates => true,\n    :verbosity => \"high\",\n    :tstress => false,\n    :ibrav => 2,\n    :tprnfor => true,\n    :nbnd => 4,\n    :electron_maxstep => 1000\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Once all the settings are set, we can create the model. If use_symm is set to true, the code will analyze and find the minimum amount of displacements that is consistent with Phonopy.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"model = create_model(path_to_calc = path_to_calc,\n                      abs_disp = abs_disp,\n                      path_to_qe = path_to_qe,\n                      mpi_ranks = mpi_ranks,\n                      sc_size = sc_size,\n                      k_mesh  = k_mesh,\n                      unitcell = unitcell,\n                      scf_parameters = scf_parameters,\n                      use_symm = use_symm);","category":"page"},{"location":"examples/#Running-code","page":"Examples","title":"Running code","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Once all the preparation is complete, all subsequent functions will operate directly with the model object. First, we could create the displaced configurations and run related DFT calculations.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"create_disp_calc!(model; from_scratch = from_scratch)\nrun_calculations(model)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nIf the calculations are run on the cluster and run.sh is present in the root directory, the calculations must be run sequentially, as run_calculations(model) is designed to execute both SCF and NSCF calculations. In this case, use the following functions, running them one by one (scf pristine and displaced, nscf pristine, nscf displaced):create_disp_calc!(model; from_scratch = from_scratch)\nrun_disp_calc(model)\nrun_nscf_calc(model)\nrun_disp_nscf_calc(model)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Once all the calculations are done, we could post-process the results. The prepare_model function will unfold pristine wave functions to the supercell and save them in the binary '*jld2' format for further post-processing. It will also call Phonopy to create a diagonal force constant matrix to access phonon data. After this, the create_electrons and create_phonons functions will create and save data for the final electron-phonon matrix element calculations. To save space and computational time create_electrons will save braket matixes beetween displaced and undisplaced wave-functions U^pm_jnmathbfk = langle psi^pm_j mid psi_nmathbfk rangle instead of wave functions itself.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"prepare_model(model)\nelectrons = create_electrons(model)\nphonons = create_phonons(model)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nIf the electrons and phonons objects were already created before, we could take advantage of the loading functions and not recalculate U^pm_jnmathbfk matrices.electrons = load_electrons(model)\nphonons = load_phonons(model)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"tip: Tip\nSince part of this code allows manipulating wave functions that QE saves in binary or HDF5 format, it is helpful to present some examples. Considering that we have QE calculation with tmp/scf.save/ folder, which contains several wave functions wfc*.dat or wfc*.hdf5, we could read them directly in Julia.miller, psi_list = parse_wf(\"./tmp/scf.save/wfc1\")QE saves wave function in reciprocal space psi_nmathbfk(mathbfr) = sum_Gpsi_nmathbfk(mathbfG) e^i(mathbfG +mathbfk)mathbfr, where psi_list is a list of wave functions coefficient for every band with N_mathbfG coefficients per band that coresponds to psi_nmathbfk(mathbfG). miller is matrix 3 times N_mathbfG that allows to resonstruct the mathbfG vector of coresponding plane wave coefficient psi_nmathbfk(mathbfG) by using (read more about wave functions in QE on Gitlab Wiki page):mathbfGi j k = textmiller1i mathbfb_1 + textmiller2i mathbfb_2 + textmiller3i mathbfb_3Having access to wave function coefficients and Miller indices, we could easily transform the wave function to real or reciprocal space as well as calculate brackets between them.N_fft = determine_fft_grid(\"./tmp/scf.save/data-file-schema.xml\"; use_xml=true)\npsi_list_R = [wf_from_G(miller, psi_G, N_fft) for psi_G in psi_list]\npsi_list_G = [wf_to_G(miller, psi_R, N_fft) for psi_R in psi_list_R]\nbraket_G = calculate_braket(psi_list_G[1],psi_list_G[2])\nbraket_R = calculate_braket_real(psi_list_R[2], psi_list_R[2])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, the final part of the calculation is the construction of the electron-phonon matrix for every k and q points of interest.  electron_phonon_qe function will try to calculate electron-phonon matrix elements directly in QE so that comparison between DFPT and FD could be made (provided a special version of ph.x is compiled). plot_ep_coupling allows simple visualization of the output quantities. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Electron-phonon matrix elements\nik_list = [i for i in 1:prod(k_mesh*sc_size)]\niq_list = [i for i in 1:prod(k_mesh*sc_size)]\n\nfor ik in ik_list\n    for iq in iq_list\n        electron_phonon_qe(model, ik, iq)# requires to compile special ph.x in testsuite/non_epw_comp\n        electron_phonon(model, ik, iq, electrons, phonons;) #save_epw = true\n        plot_ep_coupling(model, ik, iq)\n    end\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Inspecting the out folder, we could find the resulting comparison of electron-phonon matrix elements. For example for ik = 1, iq = 2, we see that FD and DFPT mathes perfectly 😎:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Comparison of electron-phonon matrix elements)","category":"page"},{"location":"examples/#Interface-with-EPW","page":"Examples","title":"Interface with EPW","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"warn: Warn\nThis section provides an interface to the EPW software. Since the usage of it is not very smooth and EPW developers are moving to storing data in HDF5 files, stay tuned for an improved version of the interface that does not require an explicit call to the Python script. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To run this section of the example we need to run part of the script that constructs electron-phonon matrix element, this time without explicit comparison with DFPT and adding aditional flag that saves data readable by EPW:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"electron_phonon(model, ik, iq, electrons, phonons; save_epw = true)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Having access to the electron-phonon matrix elements on the coarse grid, it is easy to build an interface with the relevant code that could obtain electron-phonon related properties. We are going with EPW code for this matter since it has a straightforward interface to the QE package. Continuing the example where we created displacements folder in the same place where we have the execution script, we will add a few additional files in the root folder.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"touch ph.in\ntouch epw0.in\ntouch epw1.in\ntouch epw2.in\ntouch path_k.kpt\ntouch path_q.kpt\ntouch run.sh","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"!ph.in\n&inputph\n  recover=.false.\n  tr2_ph=1.0d-17,\n  prefix='si',\n  amass(1)=28.0855,\n  outdir='./',\n  fildyn='si.dyn.xml',\n  fildvscf='dvscf'\n  ldisp=.true.,\n  nq1 = 2,\n  nq2 = 2,\n  nq3 = 2\n /","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"!epw0.in\n&inputepw\n    prefix      = 'si'\n    amass(1)    = 28.0855,\n    outdir      = './'\n    dvscf_dir   = './save/'\n    elph        = .true.\n    epbwrite    = .true.\n    epbread     = .false.\n    epwwrite    = .true.\n    epwread     = .false.\n    use_ws      = .true.\n    nbndsub     =  4\n    wannierize   = .true.\n    num_iter     = 50000\n    iprint       = 2\n    proj(1)     = 'f=0,0,0:sp3'\n\n    nkf1 = 1\n    nkf2 = 1\n    nkf3 = 1\n    nqf1 = 1\n    nqf2 = 1\n    nqf3 = 1\n    nk1  = 2\n    nk2  = 2\n    nk3  = 2\n    nq1  = 2\n    nq2  = 2\n    nq3  = 2\n /","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"!epw1.in\n--\n&inputepw\n  prefix      = 'si'\n  amass(1)    = 28.0855,\n  outdir      = './'\n  dvscf_dir   = './save/'\n  elph        = .true.\n  epbwrite    = .false.\n  epbread     = .true.\n  epwwrite    = .true.\n  epwread     = .false.\n  use_ws      = .true.\n  nbndsub        =  4\n  wannierize     = .false.\n  num_iter       = 50000\n  iprint         = 2\n  proj(1)        = 'f=0,0,0:sp3'\n  prtgkk = .true.\n  band_plot = .false.\n  \n  filkf = 'path_k.kpt'\n  filqf = 'path_q.kpt'\n  nk1  = 2\n  nk2  = 2\n  nk3  = 2\n  nq1  = 2\n  nq2  = 2\n  nq3  = 2\n /","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"!epw2.in\n&inputepw\n  prefix      = 'si'\n  amass(1)    = 28.0855,\n  outdir      = './'\n  dvscf_dir   = './save/'\n  elph        = .true.\n  epbwrite    = .false.\n  epbread     = .true.\n  epwwrite    = .true.\n  epwread     = .false.\n  use_ws      = .true.\n  nbndsub        =  4\n  wannierize     = .true.\n  num_iter       = 50000\n  iprint         = 2\n  proj(1)        = 'f=0,0,0:sp3'\n  prtgkk = .true.\n  band_plot = .false.\n  \n  filkf = 'path_k.kpt'\n  filqf = 'path_q.kpt'\n  nk1  = 2\n  nk2  = 2\n  nk3  = 2\n  nq1  = 2\n  nq2  = 2\n  nq3  = 2\n /","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"!path_k.kpt\n1 cartesian\n 0.0000000000      0.0000000000     0.0000000000  1.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"!path_q.kpt\n101 cartesian\n    1.0000000000  0.000000000  0.000000000  1.0\n    0.9800000000  0.000000000  0.000000000  1.0\n    0.9600000000  0.000000000  0.000000000  1.0\n    0.9400000000  0.000000000  0.000000000  1.0\n    0.9200000000  0.000000000  0.000000000  1.0\n    0.9000000000  0.000000000  0.000000000  1.0\n    0.8800000000  0.000000000  0.000000000  1.0\n    0.8600000000  0.000000000  0.000000000  1.0\n    0.8400000000  0.000000000  0.000000000  1.0\n    0.8200000000  0.000000000  0.000000000  1.0\n    0.8000000000  0.000000000  0.000000000  1.0\n    0.7800000000  0.000000000  0.000000000  1.0\n    0.7600000000  0.000000000  0.000000000  1.0\n    0.7400000000  0.000000000  0.000000000  1.0\n    0.7200000000  0.000000000  0.000000000  1.0\n    0.7000000000  0.000000000  0.000000000  1.0\n    0.6800000000  0.000000000  0.000000000  1.0\n    0.6600000000  0.000000000  0.000000000  1.0\n    0.6400000000  0.000000000  0.000000000  1.0\n    0.6200000000  0.000000000  0.000000000  1.0\n    0.6000000000  0.000000000  0.000000000  1.0\n    0.5800000000  0.000000000  0.000000000  1.0\n    0.5600000000  0.000000000  0.000000000  1.0\n    0.5400000000  0.000000000  0.000000000  1.0\n    0.5200000000  0.000000000  0.000000000  1.0\n    0.5000000000  0.000000000  0.000000000  1.0\n    0.4800000000  0.000000000  0.000000000  1.0\n    0.4600000000  0.000000000  0.000000000  1.0\n    0.4400000000  0.000000000  0.000000000  1.0\n    0.4200000000  0.000000000  0.000000000  1.0\n    0.4000000000  0.000000000  0.000000000  1.0\n    0.3800000000  0.000000000  0.000000000  1.0\n    0.3600000000  0.000000000  0.000000000  1.0\n    0.3400000000  0.000000000  0.000000000  1.0\n    0.3200000000  0.000000000  0.000000000  1.0\n    0.3000000000  0.000000000  0.000000000  1.0\n    0.2800000000  0.000000000  0.000000000  1.0\n    0.2600000000  0.000000000  0.000000000  1.0\n    0.2400000000  0.000000000  0.000000000  1.0\n    0.2200000000  0.000000000  0.000000000  1.0\n    0.2000000000  0.000000000  0.000000000  1.0\n    0.1800000000  0.000000000  0.000000000  1.0\n    0.1600000000  0.000000000  0.000000000  1.0\n    0.1400000000  0.000000000  0.000000000  1.0\n    0.1200000000  0.000000000  0.000000000  1.0\n    0.1000000000  0.000000000  0.000000000  1.0\n    0.0800000000  0.000000000  0.000000000  1.0\n    0.0600000000  0.000000000  0.000000000  1.0\n    0.0400000000  0.000000000  0.000000000  1.0\n    0.0200000000  0.000000000  0.000000000  1.0\n    0.0000000000  0.000000000  0.000000000  1.0\n   -0.0100000000      0.0100000000      0.0100000000  1.0\n   -0.0200000000      0.0200000000      0.0200000000  1.0\n   -0.0300000000      0.0300000000      0.0300000000  1.0\n   -0.0400000000      0.0400000000      0.0400000000  1.0\n   -0.0500000000      0.0500000000      0.0500000000  1.0\n   -0.0600000000      0.0600000000      0.0600000000  1.0\n   -0.0700000000      0.0700000000      0.0700000000  1.0\n   -0.0800000000      0.0800000000      0.0800000000  1.0\n   -0.0900000000      0.0900000000      0.0900000000  1.0\n   -0.1000000000      0.1000000000      0.1000000000  1.0\n   -0.1100000000      0.1100000000      0.1100000000  1.0\n   -0.1200000000      0.1200000000      0.1200000000  1.0\n   -0.1300000000      0.1300000000      0.1300000000  1.0\n   -0.1400000000      0.1400000000      0.1400000000  1.0\n   -0.1500000000      0.1500000000      0.1500000000  1.0\n   -0.1600000000      0.1600000000      0.1600000000  1.0\n   -0.1700000000      0.1700000000      0.1700000000  1.0\n   -0.1800000000      0.1800000000      0.1800000000  1.0\n   -0.1900000000      0.1900000000      0.1900000000  1.0\n   -0.2000000000      0.2000000000      0.2000000000  1.0\n   -0.2100000000      0.2100000000      0.2100000000  1.0\n   -0.2200000000      0.2200000000      0.2200000000  1.0\n   -0.2300000000      0.2300000000      0.2300000000  1.0\n   -0.2400000000      0.2400000000      0.2400000000  1.0\n   -0.2500000000      0.2500000000      0.2500000000  1.0\n   -0.2600000000      0.2600000000      0.2600000000  1.0\n   -0.2700000000      0.2700000000      0.2700000000  1.0\n   -0.2800000000      0.2800000000      0.2800000000  1.0\n   -0.2900000000      0.2900000000      0.2900000000  1.0\n   -0.3000000000      0.3000000000      0.3000000000  1.0\n   -0.3100000000      0.3100000000      0.3100000000  1.0\n   -0.3200000000      0.3200000000      0.3200000000  1.0\n   -0.3300000000      0.3300000000      0.3300000000  1.0\n   -0.3400000000      0.3400000000      0.3400000000  1.0\n   -0.3500000000      0.3500000000      0.3500000000  1.0\n   -0.3600000000      0.3600000000      0.3600000000  1.0\n   -0.3700000000      0.3700000000      0.3700000000  1.0\n   -0.3800000000      0.3800000000      0.3800000000  1.0\n   -0.3900000000      0.3900000000      0.3900000000  1.0\n   -0.4000000000      0.4000000000      0.4000000000  1.0\n   -0.4100000000      0.4100000000      0.4100000000  1.0\n   -0.4200000000      0.4200000000      0.4200000000  1.0\n   -0.4300000000      0.4300000000      0.4300000000  1.0\n   -0.4400000000      0.4400000000      0.4400000000  1.0\n   -0.4500000000      0.4500000000      0.4500000000  1.0\n   -0.4600000000      0.4600000000      0.4600000000  1.0\n   -0.4700000000      0.4700000000      0.4700000000  1.0\n   -0.4800000000      0.4800000000      0.4800000000  1.0\n   -0.4900000000      0.4900000000      0.4900000000  1.0\n   -0.5000000000      0.5000000000      0.5000000000  1.0    ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"#run.sh\n#!/bin/bash\n\nexport QE_PATH=\"/home/poliukhin/Soft/sourse/q-e/bin/\"\nexport NMPI=8\nexport NPOOL=8\nexport PARA_PREFIX=\"mpirun\"\nexport ELEPHANY_PATH=\"/home/poliukhin/Development/ElectronPhonon/\"\n\ncopy data ....\ncp -r ./displacements/scf_0/tmp/scf.save ./si.save\ncp -r ./displacements/scf_0/scf.out ./\necho \"0, copy finished finished\"\n\n$PARA_PREFIX -n $NMPI $QE_PATH/pw.x -npool $NPOOL -in nscf.in > nscf.out\necho \"2, nscf finished\"   \n\n$PARA_PREFIX -n $NMPI $QE_PATH/ph.x -npool $NPOOL -in ph.in > ph.out\necho \"1, ph finished\"\n\npython3 /home/poliukhin/Soft/q-e/EPW/bin/pp.py << EOF\nsi\nEOF\necho \"2, pp.py finished\"\n\nepw.x -in epw0.in  > epw0.out\necho \"3, epw0 finished\"\n\n$QE_PATH/epw.x -in epw1.in  > epw1.out\necho \"4, epw1 finished\"\n\ncp -r si.save/ si_dft.save/ \ncp si.epb1 si_dft.save/\n\npython $ELEPHANY_PATH/epw/parse_epb.py\npython $ELEPHANY_PATH/epw/fake2nscf.py\n\n$QE_PATH/epw.x < epw2.in  > epw2.out\necho \"4, epw2 finished\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the additional explanation of different options of EPW, consult the documentation. For the scf and nscf calculations, we are reusing data from the displacements/scf_0 folder. After copying the ground state calculation, we are performing phonon calculations using the ph.in input file. After converting data to the EPW readable format using the pp.py script, we run epw0.in, which creates a si.epb file containing all the essential data related to the electron-phonon calculation. This is the file that we will modify using the parse_epb.py script. The script allows parsing of a Fortran binary file and modifying related electron eigenvalues, phonon dynamical matrices, and electron-phonon matrix elements in the Kohn-Sham basis (without multiplying by the phonon eigenvector). The important caveat here is that the electron-phonon matrix is not gauge invariant, which means that we have to carry initial wave functions that were used to create the matrix to be consistent with Wannier interpolation. For this, the second script fake2nscf.py is used to copy wavefunctions and eigenvalues that were obtained with any functional to the format QE could read. These scripts are the temporary solutions to the interface and are located in the epw folder of the source code. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"After successfully parsing the electron-phonon matrix and modifying the wavefunction, we can rerun EPW using epw2.in, which will read the modified EPW files, perform wannierization, and then calculate interpolated quantities. To compare the results between DFPT and FD, we could use compare_epw.py.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"python $ELEPHANY_PATH/epw/compare_epw.py","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Comparison of electron phonon coupling with DFT and DFPT)","category":"page"},{"location":"examples/#Silicon-with-Hybrids","page":"Examples","title":"Silicon with Hybrids","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Since the proposed approach can be straightforwardly applied to any functional of interest, we could perform the same calculation, for example, for the Hybrid functional. In QE, we could do it by just adding a few additional parameters and following the rest of the example. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"scf_parameters_hse = Dict(\n :input_dft => \"HSE\",\n :nqx1 => 1,\n :nqx2 => 1,\n :nqx3 => 1\n)\n\nmerge!(scf_parameters, scf_parameters_hse)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In case any other method beyond DFT is of interest, one could intervene after the electrons and phonons object is created and change the corresponding eigenvalues and eigenvectors. By following the same calculation as the previous step, we can gain access to the electron-phonon coupling with the HSE functional.  To plot electron-phonon coupling along the path specified in path_k.kpt and path_q.kpt files, use the plot_epw.py script.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"python $ELEPHANY_PATH/epw/plot_epw.py","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Comparison of electron phonon coupling with DFT and HSE on a path)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"On this plot, FD is obtained using the HSE functional, which is inaccessible to standard DFPT 💥. As we can see, more complex functionals tend to increase the coupling, which, in the case of e.g., transport, would lower the carried drift mobility. See more arXiv prepaper for more details on this. Also, take a look at the example folder for more examples (e.g., GaAs) and stay tuned for new features in the future!","category":"page"},{"location":"#ElePhAny.jl","page":"Home","title":"ElePhAny.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"⚛️ Electron Phonon interaction with Any functional","category":"page"},{"location":"","page":"Home","title":"Home","text":"ElePhAny is a package for calculating electron-phonon matrix elements using a finite difference projectability approach, which allows obtaining electron-phonon coupling with any method beyond DFT (e.g., Hybrids, Koopmans, GW).","category":"page"},{"location":"#Capabilities","page":"Home","title":"Capabilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The code allows the construction of the electron-phonon coupling matrix from ab initio calculations using Quantum Espresso software. Additional interface with EPW allows the use of a constructed matrix to study any electron-phonon related properties of interest. Since the approach is very flexible, it enables seamless interface with any electronic structure software, especially if they are based on Quantum Espresso interface (e.g, Koopmans, Yambo)","category":"page"},{"location":"#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For full derivation and details on theory as well as application to semiconductors see the preprint: Aleksandr Poliukhin et al. arXiv:2508.14852 (2025). For a brief introduction, see the theory section of the documentation.","category":"page"},{"location":"#Quick-install","page":"Home","title":"Quick install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Download Julia.\nLaunch Julia and type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\n\npkg> https://github.com/Koulb/ElePhAny.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Alternatively) In case you want more freedom in modifyng the code you could also clone it and install in development mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://github.com/Koulb/ElePhAny.jl.git\ncd ElePhAny.jl\njulia","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> dev .","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also, for creating inputs with Python like dictionaries, consider adding the PythonCall package to your active environment:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add PythonCall","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you're new to Julia and its Pkg manager, you should definitely check out these references.","category":"page"}]
}
